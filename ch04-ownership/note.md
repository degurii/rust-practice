# Ch04: Ownership

* rust는 GC 없음
* 근데 컴파일 타임에 메모리 잘못사용하는거에 대해 인지가능, 해제된 메모리 접근 / 이중 해제 / 댕글링 참조 / 데이터 레이스 등 기존의 메모리 이슈를 방지가능
* 그에따른 트레이드오프: 소유/대여 제약을 만족하도록 코드 구조가 강제됨. 그에따라 불필요한 런타임 오버헤드가 발생하거나 코드 복잡도가 늘어나는 케이스가 있음

## 1. 소유권 기초
* C++의 일반적인 포인터 개념이 아니다. 변수와 메모리값에 대한 1:1 ownership 대응이 존재함
* 실행 흐름 속에서, 메모리는 동시에 여러 변수가 소유할 수 없다. 한 시점에 하나의 소유자만 존재할 수 있다.
* 할당된 메모리는 스코프를 벗어나는 순간 해제(drop)된다.
  -> 변수를 인자로 넘기면 소유권이 파라미터로 이동하고, 호출 지점의 변수는 더이상 사용 불가함
  -> 호출이 끝난 뒤에도 원래의 데이터를 쓰려면 반환을 통해 소유권을 돌려받거나, 처음부터 참조로 전달해야함
* 깊은 복사 용도로 `clone()` 메서가 있다
* 스택에 저장되는 타입에서 지원되는 `Copy`트레이트가 있다. 카피 가능한 타입은 다음과 같음. (대체로 일반적인 스칼라 타입)
  * 모든 정수형 타입 (예: u32)
  * true, false 값을 갖는 논리 자료형 bool
  * 모든 부동 소수점 타입 (예: f64)
  * 문자 타입 char
  * Copy 가능한 타입만으로 구성된 튜플 (예를 들어, (i32, i32)는 Copy 가능하지만 (i32, String)은 불가능합니다)

## 2. 참조와 대여 
### 대여(`borrow`)
* 소유권을 넘기지 않고, 참조자(`&`)를 통해 **대여(`borrow`)**해줄 수 있다.
* 참조자 변수가 유효한 스코프도 일반 매개변수와 동일하나, 스코프를 벗어나는 시점에 참조하는 메모리를 해제하지 않는다.
* 참조자는 대여한 힙데이터를 수정할 수 없다.

### 가변 참조자
* `fn foo(mutable_reference: &mut String)`와 같이 `mut` 키워드로 가변 참조자를 선언할 수있다.
* 가변 참조자는 대여한 힘데이터를 수정할 수 있다.
* 대신, 어떤 값에 대한 가변 참조자가 있다면, 그 값에 대한 참조자를 더 이상 만들 수 없다.
  -> 즉, 한 시점에 한 곳에서만 힙데이터를 수정할 수 있다. 
  -> 이 제약 덕에, data race를 방지할 수 있음.
* 선언의 순서가 바뀌어도 마찬가가지다. 불변 참조자가 이미 있다면, 가변 참조자를 만들 수 없다.

**참조자의 유효 범위**
* 참조자는 정의된 지점부터, 그 참조자가 마지막으로 사용된 부분까지 유효하다. 즉, 어떤 불변 참조자에 대해, 마지막 사용 지점 이후의 위치에서는 동일한 스코프여도 가변 참조자를 선언할 수 있다.
  ```rs
    let mut s = String::from("hello");

    let r1 = &s; // 문제없음
    let r2 = &s; // 문제없음
    println!("{} and {}", r1, r2);
    // 이 지점 이후로 변수 r1과 r2는 사용되지 않습니다

    let r3 = &mut s; // 문제없음
    println!("{}", r3);
  ```
**댕글링 참조**
* rust에서는 참조자를 만들면 그 참조자가 스코프를 벗어나기 전에 데이터가 먼저 스코프를 벗어나는지 컴파일러가 확인해서, 댕글링 포인터를 미리 방지할 수 있다.
* 라이프타임 개념이 있는데 나중에 나온다고 한다..

## 3. 슬라이스
